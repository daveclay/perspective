<!DOCTYPE html>
<html lang="en">
<body>
<canvas id="canvas" width="2000" height="2000"></canvas>
<style>
    body {
        margin: 0;
        padding: 0;
    }
    canvas {
        border: 1px solid red;
    }
</style>
<script>
    function isMouseInCircle(mouseX, mouseY, circleX, circleY, radius) {
        // Calculate the distance between the mouse and the circle center
        const distance = Math.sqrt((mouseX - circleX) ** 2 + (mouseY - circleY) ** 2);

        // Return true if the distance is less than or equal to the radius
        return distance <= radius;
    }

    function isMouseOnLine(mouseX, mouseY, x1, y1, x2, y2, tolerance = 5) {
        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        // Compute the projection of (mouseX, mouseY) onto the line segment
        const lengthSquared = distance(x1, y1, x2, y2) ** 2;
        if (lengthSquared === 0) return distance(mouseX, mouseY, x1, y1) <= tolerance;

        let t = ((mouseX - x1) * (x2 - x1) + (mouseY - y1) * (y2 - y1)) / lengthSquared;
        t = Math.max(0, Math.min(1, t));

        const closestX = x1 + t * (x2 - x1);
        const closestY = y1 + t * (y2 - y1);

        return distance(mouseX, mouseY, closestX, closestY) <= tolerance;
    }

    function getLineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
        const denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

        if (denominator === 0) {
            return null; // Lines are parallel or coincident
        }

        const intersectX = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / denominator;
        const intersectY = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / denominator;

        // Check if the intersection point is within both line segments
        if (
            intersectX >= Math.min(x1, x2) && intersectX <= Math.max(x1, x2) &&
            intersectY >= Math.min(y1, y2) && intersectY <= Math.max(y1, y2) &&
            intersectX >= Math.min(x3, x4) && intersectX <= Math.max(x3, x4) &&
            intersectY >= Math.min(y3, y4) && intersectY <= Math.max(y3, y4)
        ) {
            return { x: intersectX, y: intersectY };
        }

        return null; // Intersection is outside the given line segments
    }

    // TODO: this likely needs to be a method interface that calculates getX and getY rather than
    //  passing the x and y directly. That way everything is dynamically calculated from a few set points
    //  and can be moved.
    class Position {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }

        getX() {
            return this.x || 0;
        }

        getY() {
            return this.y || 0;
        }

        moveBy(dx, dy) {
            if (this.x) {
                this.x += dx;
            }

            if (this.y) {
                this.y += dy;
            }
        }
    }

    class ReferencePointPosition {
        constructor(originalPoint) {
            this.originalPoint = originalPoint;
        }

        getX() {
            return this.originalPoint.getX();
        }

        getY() {
            return this.originalPoint.getY();
        }

        moveBy(dx, dy) {
        }
    }

    class Point {
        constructor(name, position, color, offsetPosition) {
            this.name = name;
            this.position = position;
            this.color = color;
            this.offsetPosition = offsetPosition;
            this.radius = 10;
        }

        getX() {
            return this.position.getX() + this.getOffsetX();
        }

        getY() {
            return this.position.getY() + this.getOffsetY();
        }

        getOffsetX() {
            return this.offsetPosition ? this.offsetPosition.getX() : 0;
        }

        getOffsetY() {
            return this.offsetPosition ? this.offsetPosition.getY() : 0;
        }

        getPosition() {
            return new ReferencePointPosition(this);
        }

        draw(ctx) {
            ctx.moveTo(this.getX(), this.getY());
            ctx.fillStyle = this.color;
            ctx.arc(this.getX(), this.getY(), this.radius, 0, Math.PI * 2, true);
            ctx.fill();
        }

        isTarget(mouseX, mouseY) {
            return isMouseInCircle(mouseX, mouseY, this.position.getX(), this.position.getY(), this.radius);
        }

        moveBy(dx, dy) {
            if (this.offsetPosition) {
                this.offsetPosition.moveBy(dx, dy);
            } else {
                this.position.moveBy(dx, dy);
            }
        }
    }

    class ReferencePointBuilder {
        constructor(originalPoint) {
            this._originalPoint = originalPoint;
        }

        named(name) {
            this._name = name;
            return this;
        }

        color(color) {
            this._color = color;
            return this;
        }

        offsetX(distance) {
            this._offsetX = distance;
            return this;
        }

        offsetY(distance) {
            this._offsetY = distance;
            return this;
        }

        toPoint() {
            return new Point(
                this._name,
                this._originalPoint.getPosition(),
                this._color,
                new Position(this._offsetX, this._offsetY),
            );
        }
    }

    function fromPoint(point) {
        return new ReferencePointBuilder(point);
    }

    class Line {
        constructor(name, startPoint, endPoint, color) {
            this.name = name;
            this.startPoint = startPoint;
            this.endPoint = endPoint;
            this.color = color;
        }

        draw(ctx) {
            ctx.moveTo(this.startPoint.getX(), this.startPoint.getY());
            ctx.lineTo(this.endPoint.getX(), this.endPoint.getY());
            ctx.strokeStyle = this.color;
            ctx.stroke();
        }

        isTarget(mouseX, mouseY) {
            return isMouseOnLine(
                mouseX,
                mouseY,
                this.startPoint.getX(),
                this.startPoint.getY(),
                this.endPoint.getX(),
                this.endPoint.getY()
            )
        }

        moveBy(dx, dy) {
            this.startPoint.moveBy(dx, dy);
            this.endPoint.moveBy(dx, dy)
        }

        intersectionTo(otherLine) {
            const intersectionCoords = getLineIntersection(
                this.startPoint.getX(),
                this.startPoint.getY(),
                this.endPoint.getX(),
                this.endPoint.getY(),
                otherLine.startPoint.getX(),
                otherLine.startPoint.getY(),
                otherLine.endPoint.getX(),
                otherLine.endPoint.getY(),
            );

            if (!intersectionCoords) {
                return null;
            }

            // TODO: this needs to be a reference to the calculation for when the lines move, the getX and getY
            // recalculate. As in:
            // return new Position( () => calculateX(), () => calculateY );
            return new Position(intersectionCoords.x, intersectionCoords.y);
        }
    }

    class Group {
        constructor(things) {
            this.things = things;
        }

        draw(ctx) {
            for (const thing of this.things) {
                thing.draw(ctx);
            }
        }

        isTarget(mouseX, mouseY) {
            for (const thing of this.things) {
                if (thing.isTarget(mouseX, mouseY)) {
                    return true;
                }
            }
        }

        moveBy(dx, dy) {
            // remember we're moving relative.
            for (const thing of this.things) {
                thing.moveBy(dx, dy);
            }
        }
    }

    const leftHorizonVanishingPoint = new Point("leftHorizonVanishingPoint", new Position(20, 100), "red");
    const rightHorizonVanishingPoint = fromPoint(leftHorizonVanishingPoint)
        .named("rightHorizonVanishingPoint")
        .offsetX(1400)
        .color("red")
        .toPoint();
    const horizonLine = new Line("horizonLine", leftHorizonVanishingPoint, rightHorizonVanishingPoint, "red");

    const horizon = new Group([
        leftHorizonVanishingPoint,
        rightHorizonVanishingPoint,
        horizonLine
    ])

    const firstArtLineStartPont = fromPoint(leftHorizonVanishingPoint).named("firstArtLineStartPont").color("black").toPoint();
    const firstArtLineEndPoint = new Point("firstArtLineEndPoint", new Position(1097, 848), "black");
    const firstArtLine = new Line("firstArtLine", firstArtLineStartPont, firstArtLineEndPoint, "black")

    const firstArtMark = new Group([
        firstArtLineStartPont,
        firstArtLineEndPoint,
        firstArtLine
    ])

    const secondArtLineStartPont = fromPoint(leftHorizonVanishingPoint).named("secondArtLineStartPont").color("black").toPoint();
    const secondArtLineEndPont = new Point("secondArtLineEndPont", new Position(658, 851), "black");
    const secondArtLine = new Line("secondArtLine", secondArtLineStartPont, secondArtLineEndPont, "black")

    const secondArtMark = new Group([
        secondArtLineStartPont,
        secondArtLineEndPont,
        secondArtLine
    ])

    const verticalReferencePoint = fromPoint(leftHorizonVanishingPoint)
        .offsetX(600)
        .named("verticalReferencePoint")
        .color("orange")
        .toPoint();

    const verticalReferenceEndPoint = fromPoint(verticalReferencePoint)
        .offsetY(800)
        .named("verticalReferenceEndPoint")
        .color("orange")
        .toPoint();

    const verticalReferenceLine = new Line("verticalReferenceLine", verticalReferencePoint, verticalReferenceEndPoint, "orange");

    const testPoint = new Point("test", new Position(80, 45), "blue");

    const firstArtLineIntersectionPoint = new Point(
        "firstArtLineIntersectionPoint",
        firstArtLine.intersectionTo(verticalReferenceLine),
        "gray");

    const firstArtLineIntersectionLineStartPoint = fromPoint(firstArtLineIntersectionPoint)
        .offsetX(-400)
        .named("firstArtLineIntersectionLineStartPoint")
        .color("gray")
        .toPoint()

    const secondArtLineIntersectionLineStartPoint = fromPoint(firstArtLineIntersectionPoint)
        .offsetX(400)
        .named("secondArtLineIntersectionLineStartPoint")
        .color("gray")
        .toPoint()

    const firstArtLineIntersectionLine = new Line(
        "firstArtLineIntersectionLine",
        firstArtLineIntersectionLineStartPoint,
        secondArtLineIntersectionLineStartPoint,
        "gray");

    const thingsToDraw = [
        horizon,
        firstArtMark,
        secondArtMark,
        verticalReferenceLine,
        testPoint,
        firstArtLineIntersectionPoint,
        firstArtLineIntersectionLine
    ];

    function draw(ctx) {
        ctx.clearRect(0, 0, 3000, 3000);

        for (const thingToDraw of thingsToDraw) {
            ctx.beginPath();
            thingToDraw.draw(ctx);
        }

        ctx.font = "12px serif";
        ctx.fillStyle = "black";
        ctx.fillText(`${mouseX}, ${mouseY}`, 10, 50);

        window.requestAnimationFrame(() => {
            draw(ctx);
        });
    }

    function findTargetThing(mouseX, mouseY) {
        for (const thing of thingsToDraw) {
            if (thing.isTarget(mouseX, mouseY)) {
                return thing;
            }
        }
    }

    let selectedThing;
    let startMouseX = 0;
    let startMouseY = 0;
    let mouseX = 0;
    let mouseY = 0;

    function setup() {
        const canvas = document.getElementById("canvas");
        if (!canvas.getContext) {
            return;
        }

        canvas.addEventListener("mousedown", (e) => {
            startMouseX = e.pageX;
            startMouseY = e.pageY;
            selectedThing = findTargetThing(startMouseX, startMouseY);
            console.log(selectedThing);
        });

        canvas.addEventListener("mouseup", (e) => {
            selectedThing = undefined;
            startMouseX = 0;
            startMouseY = 0;
        });

        canvas.addEventListener("mousemove", (e) => {
            mouseX = e.pageX;
            mouseY = e.pageY;
            let mouseDistanceX = mouseX - startMouseX;
            let mouseDistanceY = mouseY - startMouseY;
            startMouseX = mouseX;
            startMouseY = mouseY;
            console.log(mouseDistanceX, mouseDistanceY, startMouseX, startMouseY);
            if (selectedThing) {
                selectedThing.moveBy(mouseDistanceX, mouseDistanceY);
            }
        });

        canvas.addEventListener("mouseout", (e) => {
            selectedThing = undefined;
        });

        const ctx = canvas.getContext("2d");
        window.requestAnimationFrame(() => {
            draw(ctx);
        });
    }
    setup();
</script>
</body>
</html>